The design of the chat apps - whatsapps 

reqs -- 

- people join with unique hash link , (session manager)
- login with name , Login system
- message storage  (postgresql, message_id (unique hash), name, message, time ) 
- send and store message even if offline  
- fetch message when come online  
- notifications for message 
- send and read reciepts



Session manager -- 

- The session manager uses the same hash_id for connecting the backedn and the front-end api 
- The backend has the session manager , the connect the user based on the hash and the auth 
- The front-end opens the WebSocket client to connect with backend session id, sends/recieves message via sessionid 


Flow -- 

user go to registration -- 

- The name has to be different
- register to the page 
- gets the unique_id, that has to be stored in the redis
- make the register with using go 
- Redis asscess has to made in go ?? 




## ‚úÖ High-Level Design Summary

### üîß Tech Stack Overview

| Component | Technology                    |
| --------- | ----------------------------- |
| Frontend  | Next.js, WebSocket (react-use-WebSocket)           |
| Backend   | Go (with Gorilla WebSocket)   |
| DB        | postgresql |
| Cache     | Redis (session/user/presence) |



## üîê Session Manager Logic

### ‚úÖ Backend Session Manager (in Go):

* Owns the session hash (`hash_id`)
* Verifies users during registration/login
* Connects WebSocket users using `session_id + name`
* Stores session & user info temporarily in **Redis**

### ‚úÖ Frontend (Next.js):

* Calls Go API to register a user
* Stores the hash locally (in route like `/chat/user/<hash>/message`)
* Opens WebSocket connection: `ws://yourapp/ws?session_id=<hash>&username=Abhi`


## üß≠ Flow: Registration ‚Üí Login ‚Üí Messaging

### 1Ô∏è‚É£ **Registration Phase**

#### Frontend Page

* `/chat/register` ‚Äî registration form with 2 input fields

#### Backend Endpoints

| Endpoint                              | Description                                        |
| ------------------------------------- | -------------------------------------------------- |
| `POST /chat/register/first_user_inp`  | Submit first user name                             |
| `POST /chat/register/second_user_inp` | Submit second user name                            |
| `POST /chat/register/submit`          | Final submit: validates + creates session in Redis |

#### Redis Schema Example

```redis
HSET session:<session_id> users user1 user2
EXPIRE session:<session_id> 2h
```

### 2Ô∏è‚É£ **Login Phase**

#### Frontend Pages

* `/chat/user/login` ‚Üí login UI with session ID + username input
* `/chat/user/username_submit` ‚Üí submit the username
* On success, redirect to `/chat/user/<hash>/message`

#### Backend Endpoints

| Endpoint                             | Description                   |
| ------------------------------------ | ----------------------------- |
| `POST /chat/user/username_submit`    | Check if user exists in Redis |
| `GET  /chat/user/<hash>/message_inp` | Serve message input page      |

- use the username to store the message  


### 3Ô∏è‚É£ **Chat + Messaging Phase**

#### WebSocket Connection

```ts
ws://yourserver/ws?session_id=abc123&username=Abhi
```

#### Backend WebSocket Logic:

* Validate `session_id` and `username` from Redis
* Add user to in-memory map
* Route messages
* Store each message to MongoDB:

```json
{
  "_id": ObjectId(),
  "session_id": "abc123",
  "sender_name": "Abhi",
  "content": "Hello",
  "timestamp": ISODate(),
  "read_by": [],
  "delivered_to": ["Bob"]
}
```

#### Backend Message Endpoints (optional fallback)

| Endpoint                              | Description                    |
| ------------------------------------- | ------------------------------ |
| `POST /chat/user/<hash>/message_send` | Send message (if not using WS) |





How the seession manager works and the flow -- > 

session manager is written in go , chat_id is the hash to find the user and connect the user 

the chat_id is the same hash that is generated when user register and they are given a hash 


Login --> 
can use postgresql to store the message data and also the login hash as primary key and user names 


Schema -- 

login table -- 

chat_id (hash) , user_one (name stored encrypted) , user_two (name stored encrypted)

CREATE TABLE chat.chat_login (
    chat_id TEXT PRIMARY KEY,                -- same hash from session
    user_one BYTEA NOT NULL,                 -- encrypted username
    user_two BYTEA NOT NULL                  -- encrypted username
);


message table -- 

chat_id (hash), message_id (UUID) , sender_name (name stored encrypted), reciver_name (name stored encrypted) , message (store encrypted) , timestamp , read

CREATE TABLE chat.chat_message (
    message_id     UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    chat_id        TEXT REFERENCES chat.chat_login(chat_id) ON DELETE CASCADE,
    sender_name    BYTEA NOT NULL,           -- encrypted
    receiver_name  BYTEA NOT NULL,           -- encrypted
    message        BYTEA NOT NULL,           -- encrypted
    timestamp      TIMESTAMPTZ DEFAULT now(),
    read           BOOLEAN DEFAULT false
);


- The encryption can be handled by the go layer 

The notification and the online status 

| Feature          | Backed by     | Description                        |
| ---------------- | ------------- | ---------------------------------- |
| Online status    | Redis         | `SET presence:<user>` with expiry  |
| WebSocket ping   | Redis         | Refresh `EX 300` every few seconds |
| Message delivery | WebSocket     | If online, send real-time          |
| Message fallback | Redis         | If offline, `LPUSH notify:<user>`  |
| Fetch missed     | Redis         | `LRANGE notify:<user>` on connect  |
| Scale messaging  | Redis Pub/Sub | Multi-node push sync               |



Perosonal notes -- 

The backend makes the main server using WebSocket that can run on any port and opens the bidirectional connection , also the backend is responisible for the routing system for the messsage and deliver to the client connection 
The frontend opens a WebSocket connection in the browser and then get ready to accept the connection, we need to recoginze the client connection and deliver the correct message instead to broadcasdting ? also both see the meesage 
meawhile save the message as well for  each other and keep the order correct 
two tables can be used one login table - or can be used also as message routing to find the other member, messages can be stored in the message table 
broadcast the message so both can see the message also to the coorect member can see the message as well , use the chathash_id and user1 , user2  


## The arhitecture diagram

Frontend Browser (User1) <-- WS -->|
                                   |==> Backend WebSocket Server (Go)
Frontend Browser (User2) <-- WS -->|           |
                                   |           |
                        Redis (for presence)   |
                                   |           |
                        Postgres (chat + messages)

when the user connects to the WebSocket send the user name and the chathash_id as well so the server knows where to send and receve the message 






















Links -- 

- https://medium.com/@akgol97_/building-a-restful-api-with-go-and-postgres-guide-64ccd3da6bc
- https://medium.com/@m.romaniiuk/system-design-chat-application-1d6fbf21b372


